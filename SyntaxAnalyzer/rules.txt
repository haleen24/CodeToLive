snl = [`new_line`]
separator = (`;`|`new_line`)

indexator_operator = `[`, `]`
overloadable_operator = (`+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`, `+`, `-`, `*`, `/`, `//`, `%`, `&`, `|`, `~`, `^`, `==`, `!=`, `>=`, `<=`, `>>`, `<<`, `>`, `<`, indexator_operator)

operator_overload = `operator`, overloadable_operator
conversion = `conversion`, `[`, `identifier`, `]`
attribute_name = (`identifier`|operator_overload|conversion|new)
atrribute_name_or_accessor = (attribute_name|getter|setter|inner)
attribute = expression, `.`, atrribute_name_or_accessor
indexator = expression, `[`, snl, expression, snl, `]`

optional_final = [`final`]
identifier_with_final = optional_final, `identifier`
assignable = (attribute|indexator|identifier_with_final)
assignable_sequence = {assignable, `,`}
assign_operator = (`=`|`+=`|`-=`|`*=`|`/=`, `//=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`, `&&=`, `||=`)
optional_comma = [`,`]
assign_statement = assignable_sequence, optional_comma, assign_operator, expression

parenth = `(`, snl, expression, snl, `)`
else_stmt = `else`, snl, stmt
optional_else = [else_stmt]
if_stmt = `if`, snl, parenth, snl, stmt, optional_else

while_stmt = `while`, snl, parenth, snl, stmt

optional_inline_stmt = [inline_stmt]
optional_expression = [expression]
for_stmt = `for`, snl, `(`, snl, optional_inline_stmt, snl, `;`, snl, optional_expression, snl, `;`, snl, optional_inline_stmt, snl, `)`, snl, stmt
foreach_stmt = `foreach`, snl, `(`, snl, `identifier`, snl, `:`, snl, expression, snl, `)`, snl, stmt

optional_identifier = [`identifier`]
catch_stmt = `catch`, snl, `(`, `identifier`, snl, optional_identifier, snl, `)`, snl, stmt
catch_sequence = {catch_stmt}
finally_stmt = `finally`, snl, stmt
optional_finally = [finally_stmt]
catch_block = catch_sequence, optional_else, optional_finally
try_body = (catch_block, finally)
try_stmt = `try`, snl, stmt, try_body

break_stmt = `break`
continue_stmt = `continue`
return_stmt = `return`, optional_expression
throw_stmt = `throw`, expression
import_stmt = `import`, `string_literal`

optional_static = [`static`]
field_modifier = (`final`|`computable`)
optional_field_modifier = [field_modifier]
field_stmt = optional_static, optional_field_modifier, `field`, `identifier`

named_argument = `identifier`, snl, `=`, snl, expression
comma_with_new_line = `,`, snl
positional_formal_arguments = {`identifier`, comma_with_new_line}
named_arguments = {named_argument, comma_with_new_line}
additional_named_arguments = `,`, snl, named_arguments
optional_additional_named_arguments = [additional_named_arguments]
params_argument = `params`, snl, `identifier`
additional_params_argument = `,`, snl, params_argument
optional_additional_params_argument = [additional_params_argument]
formal_arguments_with_positional = positional_formal_arguments, optional_additional_params_argument, optional_additional_named_arguments
formal_arguments_with_params = params_argument, optional_additional_named_arguments
function_formal_arguments = (formal_arguments_with_positional|formal_arguments_with_params|named_arguments)
optional_function_formal_arguments = [function_formal_arguments]
getter_declaration = `identifier`, `.`, `getter`
setter_declaration = `identifier`, `.`, `setter`
function_name = (attribute_name|getter_declaration|setter_declaration|operator_overload|conversion)
function_definition = optional_static, `func`, attribute_name, snl, `(`, snl, optional_function_formal_arguments, snl, `)`, snl, stmt

superclasses_list = {`identifier`, comma_with_new_line}
superclasses_declaration = `:`, snl, superclasses_list
optional_superclasses_declaration = [superclasses_declaration]
class_type = (`class`, `interface`)
class_definition = class_type, `identifier`, snl, optional_superclasses_declaration, snl, stmt

optional_stmt = [stmt]
nonempty_stmt_sequence = {optional_stmt, separator}
stmt_sequence = [nonempty_stmt_sequence]
block = `{`, snl, stmt_separator, snl, `}`
module = stmt_sequence, snl

positional_actual_arguments = {expression, comma_with_new_line}
actual_arguments_with_positional = positional_actual_arguments, optional_additional_named_arguments
function_actual_arguments = (actual_arguments_with_positional|named_arguments)
optional_function_actual_arguments = [function_actual_arguments]
function_call = expression, `(`, snl, optional_function_actual_arguments, snl, `)`

unary_operator = (`+`|`-`, `!`, `~`)
unary_expression = unary_operator, expression

binary_operator = (`+`, `-`, `*`, `/`, `//`, `%`, `&`, `|`, `^`, `==`, `>`, `<`, `>=`, `<=`, `!=`, `<<`, `>>`, `&&`, `||`, `is`)
expression_with_binary_operators = expression_without_binary_operators, binary_operator, expression
expression = (expression_with_binary_operators|expression_without_binary_operators)
ternary_operator_expression = expression, `?`, expression, `:`, expression

lambda = `(`, snl, function_formal_arguments, snl, `)`, `->`, stmt

inline_stmt = (assign_statement|expression)
stmt = (if_stmt|while_stmt|for_stmt|foreach_stmt|field_stmt|try_stmt|break_stmt|continue_stmt|return_stmt|throw_stmt|import_stmt|function_definition|class_definition|block|inline_stmt)
expression_without_binary_operators = (`true`|`false`|`null`|`this`|`base`|`inner`|`string_literal`|`int_literal`|`float_literal`|`identifier`|attribute|indexator|parenth|function_call|unary_expression|lambda|ternary_operator_expression)
