snl = [`new_line`]
separator = (`;`|`new_line`)

indexator_operator = `[`, `]`
overloadable_operator = (`+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`, `+`, `-`, `*`, `/`, `//`, `%`, `&`, `|`, `~`, `^`, `==`, `!=`, `>=`, `<=`, `>>`, `<<`, `>`, `<`, indexator_operator)

operator_overload = `operator`, overloadable_operator
conversion = `conversion`, `[`, `identifier`, `]`
attribute_name = (`identifier`|operator_overload|conversion|`new`)
accessor = (`getter`, `setter`)

variables = { `identifier`, `,` }
final_variables = `final`, variables
expression_sequence = {expression_without_binary_operators, `,`}
assignable_sequence = (final_variables | expression_sequence)
assign_operator = (`=`|`+=`|`-=`|`*=`|`/=`, `//=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`, `&&=`, `||=`)
optional_comma = [`,`]
assign_statement = assignable_sequence, optional_comma, assign_operator, expression

parenth = `(`, snl, expression, snl, `)`
else_stmt = `else`, snl, stmt
optional_else = [else_stmt]
if_stmt = `if`, snl, parenth, snl, stmt, optional_else

while_stmt = `while`, snl, parenth, snl, stmt

optional_inline_stmt = [inline_stmt]
optional_expression = [expression]
for_stmt = `for`, snl, `(`, snl, optional_inline_stmt, snl, `;`, snl, optional_expression, snl, `;`, snl, optional_inline_stmt, snl, `)`, snl, stmt
foreach_stmt = `foreach`, snl, `(`, snl, `identifier`, snl, `:`, snl, expression, snl, `)`, snl, stmt

optional_identifier = [`identifier`]
catch_stmt = `catch`, snl, `(`, `identifier`, snl, optional_identifier, snl, `)`, snl, stmt
catch_sequence = {catch_stmt}
finally_stmt = `finally`, snl, stmt
optional_finally = [finally_stmt]
catch_block = catch_sequence, optional_else, optional_finally
try_body = (catch_block, finally)
try_stmt = `try`, snl, stmt, try_body

break_stmt = `break`
continue_stmt = `continue`
return_stmt = `return`, optional_expression
throw_stmt = `throw`, expression
import_stmt = `import`, `string_literal`

optional_static = [`static`]
field_modifier = (`final`|`computable`)
optional_field_modifier = [field_modifier]
field_stmt = optional_static, optional_field_modifier, `field`, `identifier`

named_argument = `identifier`, snl, `=`, snl, expression
comma_with_new_line = `,`, snl
positional_formal_arguments = {`identifier`, comma_with_new_line}
named_arguments = {named_argument, comma_with_new_line}
additional_named_arguments = `,`, snl, named_arguments
optional_additional_named_arguments = [additional_named_arguments]
params_argument = `params`, snl, `identifier`
additional_params_argument = `,`, snl, params_argument
optional_additional_params_argument = [additional_params_argument]
formal_arguments_with_positional = positional_formal_arguments, optional_additional_params_argument, optional_additional_named_arguments
formal_arguments_with_params = params_argument, optional_additional_named_arguments
function_formal_arguments = (named_arguments|formal_arguments_with_positional|formal_arguments_with_params)
optional_function_formal_arguments = [function_formal_arguments]
getter_declaration = `identifier`, `.`, `getter`
setter_declaration = `identifier`, `.`, `setter`
function_name = (attribute_name|getter_declaration|setter_declaration)
function_declaration = `func`, attribute_name, snl, `(`, snl, optional_function_formal_arguments, snl, `)`
function_definition = optional_static, function_declaration, snl, stmt

superclasses_list = {`identifier`, comma_with_new_line}
superclasses_declaration = `:`, snl, superclasses_list
optional_superclasses_declaration = [superclasses_declaration]
class_definition = `class`, `identifier`, snl, optional_superclasses_declaration, snl, stmt

function_declaration_sequence = {function_declaration, separator}
function_declaration_block = `{`, snl, function_declaration_sequence, snl, `}`
interface_body = (function_declaration|function_declaration_block)
interface_definition = `interface`, `identifier`, snl, optional_superclasses_declaration, snl, interface_body

optional_stmt = [stmt]
nonempty_stmt_sequence = {optional_stmt, separator}
stmt_sequence = [nonempty_stmt_sequence]
block = `{`, snl, stmt_separator, snl, `}`
module = stmt_sequence, snl

positional_actual_arguments = {expression, comma_with_new_line}
actual_params_argument = `params`, expression
additional_actual_params_argument = `,`, snl, actual_params_argument
optional_additional_actual_params_argument = [additional_actual_params_argument]
actual_arguments_with_positional = positional_actual_arguments, optional_additional_actual_params_argument, optional_additional_named_arguments
actual_arguments_with_params = actual_params_argument, optional_additional_named_arguments
function_actual_arguments = (named_arguments|actual_arguments_with_positional|actual_arguments_with_params)
optional_function_actual_arguments = [function_actual_arguments]

unary_operator = (`+`|`-`, `!`, `~`)
unary_expression = unary_operator, expression

binary_operator = (`+`, `-`, `*`, `/`, `//`, `%`, `&`, `|`, `^`, `==`, `>`, `<`, `>=`, `<=`, `!=`, `<<`, `>>`, `&&`, `||`, `is`)
expression_with_binary_operators = expression_without_binary_operators, binary_operator, expression
expression = (expression_with_binary_operators|expression_without_binary_operators)

lambda = `(`, snl, function_formal_arguments, snl, `)`, `->`, stmt

inline_stmt = (assign_statement|expression)
stmt = (if_stmt|while_stmt|for_stmt|foreach_stmt|field_stmt|try_stmt|break_stmt|continue_stmt|return_stmt|throw_stmt|import_stmt|function_definition|class_definition|interface_definition|block|inline_stmt)

possible_attribute = (attribute_name|accessor)
attribute = `.`, possible_attribute
indexator = `[`, snl, expression, snl, `]`
function_call = `(`, snl, optional_function_actual_arguments, snl, `)`
ternary_operator = `?`, expression, `:`, expression

optional_ternary_operator = [ternary_operator]

expression_part = (attribute|indexator|function_call)
expression_part_sequence = {expression_part}
optional_expression_part_sequence = [expression_part_sequence]

atomic_expression = (`true`|`false`|`null`|`this`|`base`|`inner`|`string_literal`|`int_literal`|`float_literal`|`identifier`|parenth|unary_expression|lambda)

expression_without_binary_operators = atomic_expression, optional_expression_part_sequence, optional_ternary_operator
